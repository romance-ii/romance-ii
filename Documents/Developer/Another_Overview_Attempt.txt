Another Overview Attempt:

General Overview In Slightly-Less-Than-Painful Detail

This is an overview of what I & my team have built over the past couple of years for Tootsville. A healthy chunk of this is AGPLv3 code.

Tootsville is essentially a realtime MMO-RPG, with a heavy downplay on the RPG aspects and emphasis on social (chat) and collecting/customization (costumes, user house furniture) aspects. The current Tootsville core code is built around Appius Claudius Caecus game code, which has been designed to (potentially) support various other MMO-RPG and multiplayer game environments from a common (core) codebase.

Tootsville is based around a few major components:
Appius Claudius Caecus game server core code: Common foundation libraries and server code (Java)
Tootsville Core library code with some game-specific logic; mostly, extensions to the User (player) class with Tootsville-specific functions (Java)
Tootsville Server code, which mostly consists of in-world game logic that requires special handling, NPC scripts, and the “Run Commands” (rc) functions to bootstrap the game server. (The “main” routine is actually made in the Appius core, but it calls the game-specific rc classes)
Persephone II Flash (ActionScript) client application
Tootsville Membership & Billing, JSP-based HTML forms driven by core logic in the Appius code
TootsBook message boards, written in Google Web Toolkit (GWT) (Java compiled to JavaScript)
Toot Mirror, a small Flash applet instance of the avatar viewer code, used to embed Toot characters in TootsBook. Contains an instance of the avatar code capable of contacting Appius, “fingering” a user's ID, and assembling the avatar. 
Some PHP and Perl supporting scripts for e.g. uploading items to the database
Server architectures are split:
MySQL backing database with InnoDB tables, enforcing very simple SQL FOREIGN KEY constraints (but no other logic/constraints
Apache doing static asset serving (and some PHP/Perl scripts)
Tomcat providing JSP services and GWT server-side component hosting (M&B & TootsBook)
Appius running natively as the “game server;”
Localhost-only “emergency” access port for simple administrative commands (telnet-accessible)
“Infinity Mode” JSON communications protocol for the Flash client
Partially-developed WebSockets support for future client services
Catullus communications, which uses Java's native RMI calls to share in-game DataRecord objects across hosts to M&B, TootsBook, and so forth.
The in-game objects are mostly structured off a base class system of DataRecord and RecordLoader. (Not everything has migrated to this format, but all major classes have, and others are on their way as time permits.)
DataRecords mostly just self-identify: they provide one (or both) of “int” and “String” identifiers
RecordLoader instances perform saves (to SQL via JDBC, typically) and loads of DataRecords of their type. Different database schema (or other types of backends) can be supported using different RecordLoader classes.
Java Generics are used to enforce typing at compile-time, e.g. “public class UserRecordSQLLoader implements RecordLoader <UserRecord>”
Enumeration types which just map a series of unique strings to-and-from ID's (e.g. InventoryItemType of “hat,” “shirt,” “shoe,” …) have a simple base class that they build off of, insulating them from most of the complexity
Most DataRecords extend a common base class of SimpleDataRecord <?>. DataRecordFlushManager is called by “setter” methods in all DataRecords (usually via SimpleDataRecord.changed()) and looks at the record.getLoader () ( = RecordLoader ) .isRealtime() method provided by the specific RecordLoader class in use. Typically, calling a single setter will cause a single database update; however, calling a series of setters will instead enqueue the DataRecord for a separate “flush” thread to handle in the future. This low-priority DataRecordFlushThread runs through all “write pending” records periodically, writing them to the database as an idle background task.
All record fetches pass through Nomenclator, which has basic Nomenclator.getDataRecord (Class <? extends DataRecord>, String) and .getDataRecord (Class <? extends DataRecord>, int) methods that are type-agnostic (but type-safe, returning objects in the correct class, avoiding typecasting) and automatically references in-RAM cache, avoiding excessive database queries. When a record is removed from the cache, it forces an immediate database flush.
The RecordLoader class for a certain type of DataRecord is obtained from the configuration file, allowing them to be swapped out on the fly.
The Catullus communications system causes Nomenclator to use Catullus (aka CVC-RMI) as the RecordLoader for any data type; rather than looking for a local RecordLoader, it instead calls out to the CVC-RMI server and obtains a local copy of the object. Since CVC-RMI shows as a “realtime” RecordLoader, any calls to DataRecordFlushManager cause the changes to immediately propagate back to the master copy on the server; thus e.g.:
SQL copy: up-to-date often (by DataRecordFlushThread or direct write via SimpleDataRecord.changed () -> DataRecordFlushManager.update (…)) but not always up-to-the-minute;
RecordLoader back-end tied to SQL/JDBC
DataRecord (master copy)
CVC-RMI… over local network…
RecordLoader for CVC-RMI, pointing to master copy
DataRecord (local copy)
This system permits realtime access to shared objects and still maintains good persistence in the database without having to write every small update to the SQL server. It does exchange RAM for speed, but the cache sizes can be adjusted to control that trade-off, or even disabled so that all writes are immediately effective.
The game's principal object types include:
Toot (in Tootsville Core) extends User (which is an abstract class, requiring a few minor details from the game implementation to be fully functional), which represents an human player. User also implements the AbstractPerson interface, used in a few places in the Membership & Billing system.
User and AbstractNonPlayerCharacter extend GeneralUser, which is an abstract base class providing most of the “character” functionality in the game.
GeneralUser implements an AbstractUser interface, as does Ejecta.
AbstractNonPlayerCharacter can be directly subclassed, or the Plebeian class can be used for simplistic, scripted NPC's
Ejecta has Projectile and Particle subclasses for common cases. By treating these as “AbstractUser” instances, they can participate like very dumb NPC's without having special client-side support; e.g. a fireball being thrown across a room is just a very dumb NPC, walking very fast, with an avatar of a fireball.
Rooms are the basic unit of geography; they have room variables which define things like avatar scaling (if the room is small, the avatars are scaled up to suit, or vice-versa); “paid members only” rooms; items placed in the room (furniture, buildings, &c.); and “Places:” arbitrary polygons drawn in the GWT-based Room Editor by the designers.
“Room Places” are polygons that exit to another room. “Out places” are spawn points into which characters appear when entering from another room. “Event Places” have client-side or server-side actions associated with them; one such example are “doormats,” which are event places that cause the server to open (and close) doors based on characters walking up to them.
Room variables can be used to change the Flash animation states of items in the room. An item designed as a SWF file with multiple named MovieClips on its timeline, with each in a named keyframe, can be commanded to go to a named frame and play the MovieClip found there. This is used, for example, to open and close doors, break tree branches, turn on and off lamps, and other effects.
Room variables propagate (at room join or when changed) to all users in a room, except users in the special room “nowhere” (which suppresses all broadcast messages)
Users use a “go/do” system to issue movement/action requests. The server intentionally delays the start time of actions based upon the highest lag time measured of users in the room (ruling out any who are more than standard deviation above the average lag time, ensuring a very high degree of visual synchronization between clients. “go/do” commands are repeated to all clients with an animation name to be played (e.g. “Walk,” “Jumping,” “Sit”), start and end coördinates, a start time (in seconds since epoch, with frequent server time updates to the client to ensure sync), and a rate of travel in px/s
Events are anything that could cause the user to gain or lose items or currency. Events are started by an user, stopped at some point in the future, and can have scores associated with them. Based upon the EventType, an EventOutcome is fired at completion, which can determine rewards based upon the score earned, randomization, and other factors.
A GenericItemReference represents anything that can be placed in world or owned by a player. An InventoryItem is either active/equipped or inactive/de-equipped; it also has a health (which might represent e.g. effectiveness, ammunition, or so forth), associated assets (which vary depending on the client's needs for various types), and represents an instance of a GenericItemReference (which, in turn, defers some properties to an InventoryItemType, e.g. “hat,” “shirt,” or “furniture placed on the floor”)
InventoryItems can have Active, Passive, or Silent (no) effects. Active or Passive items, when equipped, can alter the equipping player's stats, and are echoed to the client for display in the equipped items area. Active and Passive items can have a Health Indicator (discrete, i.e. ordinal; continuous, i.e. progressive or percentile, or silent/none), and Active items occupy an Equip Slot. The client can “activate” an item in an Equip Slot by its ID character; for example, Shift+Click activates Slot 1 items in Tootsville (the only slot typically used). A console game client might instead have slots like A, B, C, Z, or so forth.
ItemEffects classes define behaviors for items, and are disjoint from their InventoryItemType. Thus, e.g. a “hat” might be simply cosmetic; might be a Passive item (e.g. “helmet providing +3 defense against Shadow attacks”); or might be an Active item (e.g. “hat with tiny gnome archer who shoots arrows upon demand”)
The Appius server itself operates off massively parallel multithreading: each connected client, each client request packet, and each background task run in a concurrent thread.

Timed events are typically launched in their own threads (although not always) from either the Metronome task or Kalendor. Metronome runs at an “unknown, variable speed” and notifies all Metronome consumers of the current time-since-epoch and time-since-last-Metronome-tick, and is used for frequently recurring events (fractional-second). Kalendor allows scheduling a future event to occur at or near a very specific time in future; e.g. the Particle class might create a “puff of smoke” which preschedules its own demise after a given interval.

The M&B system uses a “restaurant ticket” system to drive progress through various forms. User actions drive “goals,” which in turn run through a main Engine class that identifies what page to display next. A hard-coded configuration table in the Tootsville core code identifies which pages provide various form fields; the form fields providing necessary data to complete a goal are found, bringing up the appropriate display. For example, clicking a “register” button brings up a series of pages to collect desired user name, character class (initial character appearance, in Tootsville), eMail address, parental approval (if necessary), and other requisite information. When no “goal” is known, the user's M&B login state is used to “idle” to a login/register screen or a “my account” screen. (Parent accounts log in to manage their children; user accounts log in to manage themselves.) While we did begin retooling our M&B system to an “all free” model back in April, to have microtransactions for premium currency instead, that project was administratively canceled and we returned to an annual subscription model.

TootsBook operates as a basic bulletin-board/message-posting system using the “mailbox” core off the server. In-game mail goes to an “inbox;” the TootsBook “wall” operates as simply a second mailbox in the same system. User postings to their own wall are implemented as “mail from self to self,” and viewing any user's TootsBook page shows all mail “to them.” TootsBook themes are equipped items of various InventoryItemTypes. (TootsBook is currently offline administratively awaiting speed tweaks.)

Major Goals:
Code re-use and separation. Appius is “agnostic” to Tootsville, for the most part. While providing services specifically needed by Tootsville, it does not have any (or much) Tootsville-specific code. The core game code could be adapted for other projects rapidly; most of the game-specific code is actually in the M&B section. I've personally been toying with one alternate game using the same core code as a proof-of-concept, as time permits, to test/exercise this theory.
Support for internationalization and localization in the game is widespread, although probably incomplete.
Anti-cheating mechanisms (although we have a gaping architectural flaw inherited from earlier iterations of the game) are in place throughout. While we offload animation and user interface tasks to the client, all “game effective” actions are mediated by the server. For example, purchases of game items, projectile hit detection, and user stats updates.
Administrative functionality/reboot prevention. Operators can “speak” command keywords through the normal chat box to perform a variety of actions, including warning, kicking, banning, and upgrading users; blacklisting IP source addresses; creating, altering, and deleting rooms and room variables; viewing reports of server status, memory usage, highwater and current user head counts; zone creation, retirement, and destruction; loading in new rc classes; forcing database flushes; altering runtime configuration values from the config.properties file; and many other debugging and administrative commands.
Client versatility. While most access occurs through the Flash client, or CVC-RMI, the server should be easily expandable to support alternate clients (e.g. mobile apps).
Scalability. Appius is designed to spread out a single shared game world across potentially many servers, to a large extent.
Uniform experience. Appius and Persephone attempt to synchronize every user's perspective of the game to be uniform, to a great extent. (There are exceptions)